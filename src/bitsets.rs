use std::marker::PhantomData;
use self::traits::*;

pub mod traits {
    pub trait UnsignedInteger:      { }
    impl UnsignedInteger for u8     { }
    impl UnsignedInteger for u16    { }
    impl UnsignedInteger for u32    { }
    impl UnsignedInteger for u64    { }
    impl UnsignedInteger for u128   { }

    // The following methods are generated by the BitFlags macro and necessary for our extensions
    pub trait BitSetBase<B, T> where B: UnsignedInteger {
        fn bits(&self) -> B;
        fn from_bits(bits: B) -> Option<T>;
        fn is_empty(&self) -> bool;
    }

    // "BitSet" extends the generated BitFlags with extra functionality
    pub trait BitSet<B, T> where B: UnsignedInteger {
        type Iter: Iterator<Item = T>;

        fn len(&self) -> usize;
        fn iter(&self) -> Self::Iter;
        fn is_empty(&self) -> bool;
    }
}

pub struct BitSetIterator<B, T> where T: BitSetBase<B, T>, B: UnsignedInteger {
    bits: B,
    phantom: PhantomData<T>
}

impl<B, T> BitSetIterator<B, T> where T: BitSetBase<B, T>, B: UnsignedInteger {
    pub fn new(set: &T) -> BitSetIterator<B, T> {
        BitSetIterator { bits: set.bits(), phantom: PhantomData }
    }
}

// Unfortunately, simply using generic type paramaters bound to the UnsignedInteger trait is not going to be enough when
// attempting to perform operations that involve another type's values (ex: subtracting the integer '1' from the generic
// type's value). While there exist libraries that provide ways of doing this, the most lightweight solution in this
// particular case is to simply implement the traits for each of the primitive types explicitly:
macro_rules! impl_bitset {
    ($type:ty) => {
        impl<T> BitSet<$type, T> for T where T: BitSetBase<$type, T> {
            type Iter = BitSetIterator<$type, T>;
        
            fn len(&self) -> usize {
                // Brian Kernighan's algorithm for counting set bits
                let mut n = self.bits();
                let mut count = 0;
                while n > 0 {
                    n = n & (n - 1);
                    count += 1
                }
                count
            }

            #[inline]
            fn is_empty(&self) -> bool {
                self.is_empty()
            }
        
            fn iter(&self) -> Self::Iter {
                Self::Iter::new(self)
            }
        }
        
        impl<T> Iterator for BitSetIterator<$type, T>
        where T: BitSetBase<$type, T> {
            type Item = T;
        
            fn next(&mut self) -> Option<Self::Item> {
                if self.bits > 0 {
                    let previous = self.bits;
                    self.bits = self.bits & (self.bits - 1);
        
                    Self::Item::from_bits(previous ^ self.bits)
                } else {
                    None
                }
            }
        }
    };
}

impl_bitset!(u8);
impl_bitset!(u16);
impl_bitset!(u32);
impl_bitset!(u64);
impl_bitset!(u128);
